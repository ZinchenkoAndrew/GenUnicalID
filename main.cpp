/*
ЗАДАНИЕ:
Есть последовательность идентификаторов, строящаяся по следующим правилам:
1. Первый идентификатор последовательности имеет вид «A1», второй — «A2», третий - «A3» и так далее. За «A9» следует «B1». Следующий после «Z9» имеет вид «A1-A1», потом «A1-A2» и так далее. После «A1-Z9» следует «A2-A1».
2. Максимальная длина идентификатора - десять групп по два символа.
3. В идентификаторах никогда не должны присутствовать буквы «D», «F», «G», «J», «M», «Q», «V» и цифра «0».
Необходимо реализовать класс, обеспечивающий работу с идентификатором по заданным правилам.
Класс должен обладать следующим функционалом:
• Метод, устанавливающий текущее значение идентификатора
• Метод, инкрементирующий значение идентификатора и возвращающий новое значение
Технические требования к решению:
1. Код должен быть потокобезопасным.
2. Код должен компилироваться.
3. Код должен быть кроссплатформенным (успешно собираться компиляторами msvc/gcc/clang).
4. Для решения задачи разрешается использовать только стандартную библиотеку С++(стандарт до C++17 включительно).
*/

//Включаем заголовки STL
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>

//Включаем заголовочный файл нашего кдасса GenID:
#include "GenID.h"


//Глобальные переменные

GenID id;//Объект нашего класса
std::mutex cout_mutex;//мьютекс для разделенного доступа к консоли
std::mutex mtx;//мьютекс для разделенного доступа к методам класса


//Фоновый поток для тестирования записи(установки) ID
void thread_set()
{
    //std::string idStr{"A1-A2-A3-A4-A5-A6-A7-A8-A9-B1"};
    std::string idStr{ "Z8-Z9-Z9-Z9-Z9-Z9-Z9-Z9-Z9-Z1" };
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    std::lock_guard<std::mutex> guard(mtx);
    bool res = id.setNewID(idStr);
    std::lock_guard<std::mutex> cout_guard(cout_mutex);
    std::cout << "set ID to " << idStr << " ,result " << (res?"OK":"ERROR") << std::endl;
}

//Фоновый поток(запускается в N-потоков),каждый поток вызывает метод,
//получающий новый инкремент ID:
void thread_inc(int idOfThread)
{
    std::string idStr{};
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::lock_guard<std::mutex> guard(mtx);
    id.incAndReturnID(idStr);
    std::lock_guard<std::mutex> cout_guard(cout_mutex);
    std::cout << "ID is " << idStr << " ,Thread " << idOfThread << std::endl;
    
}

//кол.-во одновременно запускаемых потоков:
const size_t nThreads = 1000;

//Идея теста такова: создается многопоточный запрос инкремента ID
//Каждый поток выводит полученное значение ID+=1
//Параллельно(с небольшой задержкой) в отдельном потоке устанавливаем
//новое значение ID. С момента успешной установки потоки начинают получать 
//новые значения(с новым базисом) ID.
/////////////////////////код основной программы/////////////////////////////////////////
int main()
{
    //Вектор потоков с инкрементом
    std::vector<std::thread> tv;

    //Вызываем поток с принудительной установкой ID
    std::thread tSet(thread_set);
    
    //Вызываем потоки инкремента
    for (int i = 0; i < nThreads; i++)
    {
        tv.push_back(std::thread(thread_inc,i));
    }

    //Ждем их завершения
    for (int i = 0; i < nThreads; i++)
    {
        tv[i].join();
    }

    //Ждем завершения потока принудительной установки ID
    tSet.join();
                    
}
///////////////////////////////////////////////////////////////////
